{
  "name": "Orientpoj.GitHub.io",
  "tagline": "POJ_1011",
  "body": "# OrientPOJ.github.io\r\nPOJ_1011\r\n\r\nSticks\r\nTime Limit: 1000MS\t\tMemory Limit: 10000K\r\nTotal Submissions: 147984\t\tAccepted: 35082\r\n\r\n简介：\r\n乔治拿来一组等长的木棒，将它们随机地裁断，使得每一节木棒的长度都不超过50个长度单位。然后他又想把这些木棒恢复到为裁截前的状态，但忘记了木棒的初始长度。请你设计一个程序，帮助乔治计算木棒的可能最小长度。每一节木棒的长度都用大于零的整数表示\r\n \r\n输入：由多个案例组成，每个案例包括两行。第一行是一个不超过64的整数，表示裁截之后共有多少节木棒。第二行是经过裁截后，所得到的各节木棒的长度。在最后一个案例之后，是零。\r\n \r\n输出：为每个案例，分别输出木棒的可能最小长度。每个案例占一行。\r\n\r\nSample Input\r\n9\r\n5 2 1 5 2 1 5 2 1\r\n4\r\n1 2 3 4\r\n0\r\nSample Output\r\n\r\n6\r\n5\r\n\r\n题解：\r\n\r\n我大概理解了一下这个题，是要给我n 木棍碎片，要求还原原木棍，且原木棍等长，问最短长度是多少。\r\n\r\n其实按照我没有接触算法之前的想法，我只能想到暴力解决，虽然最后解决了问题，但是在poj上提交了之后一直\r\n\r\n时间超出，最后我看了一些大神的解答，还有讨论区别人的代码，才知道这是一个剪枝算法题。\r\n\r\n关键在于三个剪枝，如下：\r\n\r\n1.如果某根木棒的长度不能构成，则之后的相同长度的也不行.\r\n\r\n2.如果把某段拿去构成木棒的最后一截后，剩下的无法完成，那么也不可能. \r\n\r\n3.如果在构成某根木棒的第一段时最大的无法用上，那么直接不可能.\r\n\r\n这里贴出代码，现在是2017年9月10日23：22\r\n\r\n代码：\r\n\r\n/*\r\n注意三个重要剪枝 \r\n2016/11/8\r\n*/ \r\n#include <cstdlib>\r\n#include <iostream>\r\n#include<algorithm>\r\n\r\nusing namespace std;\r\n\r\nint l[65];          //所有木棍 \r\nint visited[65];    //记录所有木棍是否被访问 \r\nint len;            //木棍 \r\nint n;              //木棍个数 \r\nint sum;            //木棍长和 \r\n\r\nbool cmp(int a,int b)\r\n{\r\n  return a>b;\r\n}\r\n\r\n\r\nbool research(int pos, int res, int cnt)\r\n{   //如果构成了所有，返回 \r\n    if (cnt*len == sum)\r\n        return true;\r\n    for(int i=pos; i<n; i++)\r\n    {\r\n        //如被访问，退出 \r\n        /*if(visited[i] == 1)\r\n            continue;*/\r\n        //1某根木棒的长度不能构成，则之后的相同长度的也不行. \r\n       if(visited[i] || (i && !visited[i-1] && l[i] == l[i-1])) continue;\r\n\r\n        if(res+l[i] == len)\r\n        {\r\n                visited[i] = 1;    \r\n                if(research(0, 0, cnt+1))\r\n                    return true;\r\n                \r\n                visited[i] = 0;\r\n                //2如果把某段拿去构成木棒的最后一截后，剩下的无法完成，那么也不可能.\r\n                return false;\r\n        }\r\n        else if(res+l[i] < len)\r\n        {\r\n            visited[i] = 1;\r\n            if(research(pos+1, res+l[i], cnt))\r\n                return true;\r\n            visited[i] = 0;\r\n            //3如果在构成某根木棒的第一段时最大的无法用上，那么直接不可能.\r\n            if(res == 0) return false;\r\n        }\r\n            \r\n    }        \r\n \r\n    return false;\r\n}\r\n\r\nint solve()\r\n{\r\n            //整数排序\r\n              sort(l,l+n,cmp);\r\n       \r\n              for(len=l[0]; len<sum; len++)\r\n              {     \r\n                    \r\n                    if(sum%len == 0)\r\n                    {\r\n                        memset(visited, 0, sizeof(visited));\r\n                        if(research(0, 0, 0))\r\n                        {\r\n                          break;\r\n                        }  \r\n                                  \r\n                    }\r\n              }\r\n            \r\n            return len;\r\n}\r\nint main(void)\r\n{\r\n    while(cin >> n && n!= 0)\r\n    {   \r\n             sum = 0;\r\n              //memset(l,0,sizeof(l));\r\n              for(int i=0; i<n; i++)\r\n              {        \r\n                       cin >> l[i];\r\n                       sum+=l[i];\r\n              }\r\n              \r\n              cout << solve() << endl;\r\n       \r\n    }\r\n    system(\"PAUSE\");\r\n    return 0;\r\n}\r\n\r\n\r\n补充：这段代码是在DEV-C++上实现完成。",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}